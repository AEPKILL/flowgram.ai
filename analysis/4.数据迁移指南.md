# 数据迁移指南

本文档详细介绍如何在 FlowGram.AI 中实现数据版本管理和迁移策略，确保应用升级时用户数据的平滑过渡。

## 目录

1. [为什么需要数据迁移](#1-为什么需要数据迁移)
2. [版本管理策略](#2-版本管理策略)
3. [迁移系统设计](#3-迁移系统设计)
4. [实现数据迁移](#4-实现数据迁移)
5. [迁移测试](#5-迁移测试)
6. [最佳实践](#6-最佳实践)
7. [完整示例](#7-完整示例)

---

## 1. 为什么需要数据迁移

### 常见场景

在应用迭代过程中，数据结构可能发生变化：

```typescript
// ❌ 旧版本 (v1.0.0)
class StyleData extends EntityData<{
  color: string;
  opacity: number;
}> {
  // ...
}

// ✅ 新版本 (v2.0.0) - 添加了新字段
class StyleData extends EntityData<{
  color: string;
  opacity: number;
  visible: boolean;        // 新增字段
  borderWidth: number;     // 新增字段
  borderColor: string;     // 新增字段
}> {
  // ...
}
```

**问题**：如果直接加载旧版本数据，新增字段会缺失或使用错误的默认值。

### 需要迁移的典型情况

| 变更类型 | 示例 | 影响 |
|---------|------|------|
| **字段新增** | 添加 `visible` 字段 | 旧数据缺少该字段 |
| **字段重命名** | `color` → `fillColor` | 旧数据字段名不匹配 |
| **字段删除** | 删除 `deprecated` 字段 | 旧数据包含无用字段 |
| **类型变更** | `opacity: number` → `opacity: string` | 数据类型不兼容 |
| **数据结构调整** | `position: {x, y}` → `transform: {x, y, rotation}` | 结构不匹配 |
| **实体类型重构** | `RectEntity` → `ShapeEntity` | 类型名称变更 |

---

## 2. 版本管理策略

### 2.1 语义化版本控制

遵循 [Semantic Versioning](https://semver.org/)：

```
版本格式：MAJOR.MINOR.PATCH

- MAJOR: 不兼容的 API 变更（需要数据迁移）
- MINOR: 向后兼容的功能新增（可能需要迁移）
- PATCH: 向后兼容的问题修复（通常不需要迁移）
```

### 2.2 版本信息存储

在序列化数据中记录版本信息：

```typescript
interface VersionedEntityJSON {
  version: string;           // 数据版本号
  entities: EntityJSON[];    // 实体数据
  metadata?: {               // 可选元数据
    createdAt: string;
    updatedAt: string;
    appVersion: string;
  };
}
```

**示例：**

```typescript
{
  "version": "2.0.0",
  "entities": [
    {
      "type": "RectangleEntity",
      "id": "rect-001",
      "dataList": [...]
    }
  ],
  "metadata": {
    "createdAt": "2024-01-15T10:30:00Z",
    "updatedAt": "2024-03-20T14:45:00Z",
    "appVersion": "2.0.0"
  }
}
```

---

## 3. 迁移系统设计

### 3.1 迁移器接口定义

```typescript
/**
 * 迁移器接口
 */
interface Migration {
  /** 源版本 */
  fromVersion: string;

  /** 目标版本 */
  toVersion: string;

  /** 迁移描述 */
  description: string;

  /**
   * 执行迁移
   * @param data 旧版本数据
   * @returns 新版本数据
   */
  migrate(data: any): any;

  /**
   * 验证迁移结果（可选）
   * @param data 迁移后的数据
   * @returns 是否验证通过
   */
  validate?(data: any): boolean;
}
```

### 3.2 迁移管理器

```typescript
/**
 * 迁移管理器 - 负责协调和执行迁移链
 */
class MigrationManager {
  private migrations: Migration[] = [];

  /**
   * 注册迁移器
   */
  register(migration: Migration): void {
    this.migrations.push(migration);
    // 按版本排序，确保迁移顺序正确
    this.migrations.sort((a, b) =>
      this.compareVersion(a.fromVersion, b.fromVersion)
    );
  }

  /**
   * 执行迁移
   * @param data 原始数据
   * @param fromVersion 当前版本
   * @param toVersion 目标版本
   */
  migrate(data: any, fromVersion: string, toVersion: string): any {
    // 查找迁移路径
    const migrationPath = this.findMigrationPath(fromVersion, toVersion);

    if (migrationPath.length === 0) {
      console.log(`无需迁移：版本 ${fromVersion} → ${toVersion}`);
      return data;
    }

    console.log(`开始迁移：${fromVersion} → ${toVersion}`);
    console.log(`迁移路径：`, migrationPath.map(m =>
      `${m.fromVersion} → ${m.toVersion}`
    ).join(' → '));

    // 逐步执行迁移链
    let migratedData = data;
    for (const migration of migrationPath) {
      console.log(`执行迁移：${migration.description}`);

      try {
        migratedData = migration.migrate(migratedData);

        // 验证迁移结果
        if (migration.validate && !migration.validate(migratedData)) {
          throw new Error(`迁移验证失败：${migration.description}`);
        }
      } catch (error) {
        console.error(`迁移失败：${migration.description}`, error);
        throw error;
      }
    }

    console.log(`迁移完成：${fromVersion} → ${toVersion}`);
    return migratedData;
  }

  /**
   * 查找迁移路径（支持跨版本迁移）
   */
  private findMigrationPath(
    fromVersion: string,
    toVersion: string
  ): Migration[] {
    const path: Migration[] = [];
    let currentVersion = fromVersion;

    while (currentVersion !== toVersion) {
      const nextMigration = this.migrations.find(
        m => m.fromVersion === currentVersion
      );

      if (!nextMigration) {
        throw new Error(
          `找不到迁移路径：${currentVersion} → ${toVersion}`
        );
      }

      path.push(nextMigration);
      currentVersion = nextMigration.toVersion;
    }

    return path;
  }

  /**
   * 版本比较（简化版）
   */
  private compareVersion(v1: string, v2: string): number {
    const parts1 = v1.split('.').map(Number);
    const parts2 = v2.split('.').map(Number);

    for (let i = 0; i < 3; i++) {
      if (parts1[i] !== parts2[i]) {
        return parts1[i] - parts2[i];
      }
    }
    return 0;
  }

  /**
   * 获取所有注册的迁移器
   */
  getMigrations(): Migration[] {
    return [...this.migrations];
  }
}
```

---

## 4. 实现数据迁移

### 4.1 场景一：字段新增

**变更描述**：`StyleData` 新增 `visible` 字段

```typescript
/**
 * 迁移：v1.0.0 → v1.1.0
 * 为 StyleData 添加 visible 字段（默认为 true）
 */
const migration_v1_0_0_to_v1_1_0: Migration = {
  fromVersion: '1.0.0',
  toVersion: '1.1.0',
  description: '为 StyleData 添加 visible 字段',

  migrate(data: VersionedEntityJSON): VersionedEntityJSON {
    return {
      ...data,
      version: '1.1.0',
      entities: data.entities.map(entity => ({
        ...entity,
        dataList: entity.dataList.map(dataItem => {
          // 只处理 StyleData
          if (dataItem.type === 'StyleData') {
            return {
              ...dataItem,
              data: {
                ...dataItem.data,
                visible: true,  // 新增字段，默认值为 true
              },
            };
          }
          return dataItem;
        }),
      })),
    };
  },

  validate(data: VersionedEntityJSON): boolean {
    // 验证所有 StyleData 都包含 visible 字段
    return data.entities.every(entity =>
      entity.dataList
        .filter(d => d.type === 'StyleData')
        .every(d => typeof d.data.visible === 'boolean')
    );
  },
};
```

### 4.2 场景二：字段重命名

**变更描述**：`color` 字段重命名为 `fillColor`

```typescript
/**
 * 迁移：v1.1.0 → v2.0.0
 * 将 StyleData 的 color 字段重命名为 fillColor
 */
const migration_v1_1_0_to_v2_0_0: Migration = {
  fromVersion: '1.1.0',
  toVersion: '2.0.0',
  description: '重命名 color → fillColor',

  migrate(data: VersionedEntityJSON): VersionedEntityJSON {
    return {
      ...data,
      version: '2.0.0',
      entities: data.entities.map(entity => ({
        ...entity,
        dataList: entity.dataList.map(dataItem => {
          if (dataItem.type === 'StyleData') {
            const { color, ...rest } = dataItem.data;
            return {
              ...dataItem,
              data: {
                ...rest,
                fillColor: color,  // 重命名字段
              },
            };
          }
          return dataItem;
        }),
      })),
    };
  },

  validate(data: VersionedEntityJSON): boolean {
    // 验证：新字段存在，旧字段不存在
    return data.entities.every(entity =>
      entity.dataList
        .filter(d => d.type === 'StyleData')
        .every(d =>
          d.data.fillColor !== undefined &&
          d.data.color === undefined
        )
    );
  },
};
```

### 4.3 场景三：数据结构重构

**变更描述**：`PositionData` 增加旋转角度

```typescript
// 旧结构
interface OldPositionData {
  x: number;
  y: number;
}

// 新结构
interface NewTransformData {
  x: number;
  y: number;
  rotation: number;  // 新增
  scale: number;     // 新增
}

/**
 * 迁移：v2.0.0 → v3.0.0
 * PositionData 重构为 TransformData，增加 rotation 和 scale
 */
const migration_v2_0_0_to_v3_0_0: Migration = {
  fromVersion: '2.0.0',
  toVersion: '3.0.0',
  description: 'PositionData → TransformData（增加旋转和缩放）',

  migrate(data: VersionedEntityJSON): VersionedEntityJSON {
    return {
      ...data,
      version: '3.0.0',
      entities: data.entities.map(entity => ({
        ...entity,
        dataList: entity.dataList.map(dataItem => {
          // 将 PositionData 转换为 TransformData
          if (dataItem.type === 'PositionData') {
            return {
              type: 'TransformData',  // 类型名称也变更
              data: {
                x: dataItem.data.x,
                y: dataItem.data.y,
                rotation: 0,   // 新增字段：默认无旋转
                scale: 1,      // 新增字段：默认不缩放
              },
            };
          }
          return dataItem;
        }),
      })),
    };
  },

  validate(data: VersionedEntityJSON): boolean {
    // 验证：不存在旧的 PositionData，所有 TransformData 包含完整字段
    return data.entities.every(entity => {
      const hasOldType = entity.dataList.some(d => d.type === 'PositionData');
      const transformData = entity.dataList.filter(d => d.type === 'TransformData');
      const transformValid = transformData.every(d =>
        typeof d.data.x === 'number' &&
        typeof d.data.y === 'number' &&
        typeof d.data.rotation === 'number' &&
        typeof d.data.scale === 'number'
      );
      return !hasOldType && transformValid;
    });
  },
};
```

### 4.4 场景四：实体类型更名

**变更描述**：`RectangleEntity` 重构为通用的 `ShapeEntity`

```typescript
/**
 * 迁移：v3.0.0 → v4.0.0
 * RectangleEntity 重命名为 ShapeEntity，并添加 shapeType 字段
 */
const migration_v3_0_0_to_v4_0_0: Migration = {
  fromVersion: '3.0.0',
  toVersion: '4.0.0',
  description: 'RectangleEntity → ShapeEntity（通用化）',

  migrate(data: VersionedEntityJSON): VersionedEntityJSON {
    return {
      ...data,
      version: '4.0.0',
      entities: data.entities.map(entity => {
        if (entity.type === 'RectangleEntity') {
          return {
            ...entity,
            type: 'ShapeEntity',  // 实体类型更名
            dataList: [
              ...entity.dataList,
              // 添加新的 ShapeTypeData 来区分形状类型
              {
                type: 'ShapeTypeData',
                data: {
                  shapeType: 'rectangle',  // 记录原始类型
                },
              },
            ],
          };
        }
        return entity;
      }),
    };
  },

  validate(data: VersionedEntityJSON): boolean {
    // 验证：不存在旧的 RectangleEntity
    const hasOldType = data.entities.some(e => e.type === 'RectangleEntity');

    // 所有新的 ShapeEntity 都包含 ShapeTypeData
    const shapeEntities = data.entities.filter(e => e.type === 'ShapeEntity');
    const hasShapeType = shapeEntities.every(e =>
      e.dataList.some(d => d.type === 'ShapeTypeData')
    );

    return !hasOldType && hasShapeType;
  },
};
```

### 4.5 场景五：复杂数据转换

**变更描述**：颜色格式从 HEX 转换为 RGBA

```typescript
/**
 * 迁移：v4.0.0 → v4.1.0
 * 颜色格式：HEX → RGBA
 */
const migration_v4_0_0_to_v4_1_0: Migration = {
  fromVersion: '4.0.0',
  toVersion: '4.1.0',
  description: '颜色格式转换：HEX → RGBA',

  migrate(data: VersionedEntityJSON): VersionedEntityJSON {
    return {
      ...data,
      version: '4.1.0',
      entities: data.entities.map(entity => ({
        ...entity,
        dataList: entity.dataList.map(dataItem => {
          if (dataItem.type === 'StyleData' && dataItem.data.fillColor) {
            const hexColor = dataItem.data.fillColor as string;
            const rgbaColor = this.hexToRgba(hexColor, dataItem.data.opacity || 1);

            return {
              ...dataItem,
              data: {
                ...dataItem.data,
                fillColor: rgbaColor,
              },
            };
          }
          return dataItem;
        }),
      })),
    };
  },

  // 辅助函数：HEX 转 RGBA
  hexToRgba(hex: string, opacity: number): string {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
  },

  validate(data: VersionedEntityJSON): boolean {
    // 验证所有颜色都是 RGBA 格式
    const rgbaPattern = /^rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*[\d.]+\)$/;

    return data.entities.every(entity =>
      entity.dataList
        .filter(d => d.type === 'StyleData' && d.data.fillColor)
        .every(d => rgbaPattern.test(d.data.fillColor))
    );
  },
};
```

---

## 5. 迁移测试

### 5.1 单元测试

```typescript
import { describe, it, expect } from 'vitest';

describe('数据迁移测试', () => {
  it('应该正确添加新字段', () => {
    // 准备旧版本数据
    const oldData: VersionedEntityJSON = {
      version: '1.0.0',
      entities: [
        {
          type: 'RectangleEntity',
          id: 'rect-001',
          dataList: [
            {
              type: 'StyleData',
              data: {
                color: '#FF5733',
                opacity: 0.8,
              },
            },
          ],
        },
      ],
    };

    // 执行迁移
    const newData = migration_v1_0_0_to_v1_1_0.migrate(oldData);

    // 验证结果
    expect(newData.version).toBe('1.1.0');
    expect(newData.entities[0].dataList[0].data.visible).toBe(true);
  });

  it('应该正确重命名字段', () => {
    const oldData: VersionedEntityJSON = {
      version: '1.1.0',
      entities: [
        {
          type: 'RectangleEntity',
          id: 'rect-001',
          dataList: [
            {
              type: 'StyleData',
              data: {
                color: '#FF5733',
                opacity: 0.8,
                visible: true,
              },
            },
          ],
        },
      ],
    };

    const newData = migration_v1_1_0_to_v2_0_0.migrate(oldData);

    expect(newData.entities[0].dataList[0].data.fillColor).toBe('#FF5733');
    expect(newData.entities[0].dataList[0].data.color).toBeUndefined();
  });

  it('应该正确执行跨版本迁移链', () => {
    const manager = new MigrationManager();
    manager.register(migration_v1_0_0_to_v1_1_0);
    manager.register(migration_v1_1_0_to_v2_0_0);

    const oldData: VersionedEntityJSON = {
      version: '1.0.0',
      entities: [
        {
          type: 'RectangleEntity',
          id: 'rect-001',
          dataList: [
            {
              type: 'StyleData',
              data: {
                color: '#FF5733',
                opacity: 0.8,
              },
            },
          ],
        },
      ],
    };

    // 一次性从 v1.0.0 迁移到 v2.0.0
    const newData = manager.migrate(oldData, '1.0.0', '2.0.0');

    expect(newData.version).toBe('2.0.0');
    expect(newData.entities[0].dataList[0].data.fillColor).toBe('#FF5733');
    expect(newData.entities[0].dataList[0].data.visible).toBe(true);
  });
});
```

### 5.2 集成测试

```typescript
describe('EntityManager 迁移集成测试', () => {
  it('应该在还原时自动执行迁移', () => {
    // 创建 EntityManager 和 MigrationManager
    const entityManager = new EntityManager();
    const migrationManager = new MigrationManager();

    // 注册迁移器
    migrationManager.register(migration_v1_0_0_to_v1_1_0);
    migrationManager.register(migration_v1_1_0_to_v2_0_0);

    // 准备旧版本数据
    const savedData = {
      version: '1.0.0',
      entities: [/* ... */],
    };

    // 执行迁移
    const currentVersion = '2.0.0';
    const migratedData = migrationManager.migrate(
      savedData,
      savedData.version,
      currentVersion
    );

    // 还原实体
    entityManager.restoreState(migratedData.entities);

    // 验证实体数据正确
    const entity = entityManager.getEntityById('rect-001');
    const styleData = entity?.getData(StyleData);

    expect(styleData?.data.fillColor).toBe('#FF5733');
    expect(styleData?.data.visible).toBe(true);
  });
});
```

---

## 6. 最佳实践

### 6.1 版本标识

✅ **推荐：在存储数据时始终记录版本**

```typescript
function saveWithVersion(entityManager: EntityManager) {
  const currentVersion = '2.0.0';  // 从配置或 package.json 读取

  const data: VersionedEntityJSON = {
    version: currentVersion,
    entities: entityManager.storeState({ configOnly: false }),
    metadata: {
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      appVersion: currentVersion,
    },
  };

  localStorage.setItem('flowgram-state', JSON.stringify(data));
}
```

### 6.2 向后兼容

✅ **推荐：新字段提供合理的默认值**

```typescript
class StyleData extends EntityData<{
  fillColor: string;
  opacity: number;
  visible: boolean;      // 新字段
  borderWidth: number;   // 新字段
}> {
  getDefaultData() {
    return {
      fillColor: '#000000',
      opacity: 1,
      visible: true,        // ✅ 合理的默认值
      borderWidth: 0,       // ✅ 合理的默认值
    };
  }
}
```

### 6.3 迁移失败处理

✅ **推荐：提供降级方案**

```typescript
function restoreWithMigration(entityManager: EntityManager) {
  try {
    const savedJSON = localStorage.getItem('flowgram-state');
    if (!savedJSON) return;

    const data = JSON.parse(savedJSON);
    const currentVersion = '2.0.0';

    // 尝试迁移
    if (data.version !== currentVersion) {
      const migratedData = migrationManager.migrate(
        data,
        data.version,
        currentVersion
      );
      entityManager.restoreState(migratedData.entities);
    } else {
      entityManager.restoreState(data.entities);
    }
  } catch (error) {
    console.error('迁移失败，使用降级方案', error);

    // 降级方案1：尝试直接还原（可能部分数据丢失）
    try {
      entityManager.restoreState(data.entities);
    } catch {
      // 降级方案2：清空数据，重新开始
      console.warn('无法还原数据，已清空');
      localStorage.removeItem('flowgram-state');
    }
  }
}
```

### 6.4 迁移日志

✅ **推荐：记录迁移历史**

```typescript
interface MigrationLog {
  timestamp: string;
  fromVersion: string;
  toVersion: string;
  success: boolean;
  error?: string;
}

class MigrationManager {
  private logs: MigrationLog[] = [];

  migrate(data: any, fromVersion: string, toVersion: string): any {
    const log: MigrationLog = {
      timestamp: new Date().toISOString(),
      fromVersion,
      toVersion,
      success: false,
    };

    try {
      const result = this.executeMigration(data, fromVersion, toVersion);
      log.success = true;
      this.logs.push(log);
      return result;
    } catch (error) {
      log.error = String(error);
      this.logs.push(log);
      throw error;
    }
  }

  getMigrationLogs(): MigrationLog[] {
    return this.logs;
  }
}
```

### 6.5 数据备份

✅ **推荐：迁移前备份数据**

```typescript
function migrateWithBackup(data: VersionedEntityJSON) {
  // 备份原始数据
  const backupKey = `flowgram-backup-${data.version}-${Date.now()}`;
  localStorage.setItem(backupKey, JSON.stringify(data));

  try {
    // 执行迁移
    const migratedData = migrationManager.migrate(
      data,
      data.version,
      currentVersion
    );

    // 迁移成功，保存新数据
    localStorage.setItem('flowgram-state', JSON.stringify(migratedData));

    // 清理旧备份（可选）
    cleanOldBackups();

    return migratedData;
  } catch (error) {
    // 迁移失败，从备份恢复
    console.error('迁移失败，已恢复备份', error);
    const backup = localStorage.getItem(backupKey);
    if (backup) {
      localStorage.setItem('flowgram-state', backup);
    }
    throw error;
  }
}

function cleanOldBackups() {
  const maxBackups = 5;
  const backupKeys = Object.keys(localStorage)
    .filter(key => key.startsWith('flowgram-backup-'))
    .sort()
    .reverse();

  // 保留最近的 N 个备份
  backupKeys.slice(maxBackups).forEach(key => {
    localStorage.removeItem(key);
  });
}
```

---

## 7. 完整示例

以下是一个完整的数据迁移系统实现：

```typescript
import {
  Entity,
  EntityData,
  EntityManager,
  type EntityDataRegistry,
  type EntityJSON,
} from '@flowgram.ai/canvas-engine/core';

// ========== 版本化数据结构 ==========

interface VersionedEntityJSON {
  version: string;
  entities: EntityJSON[];
  metadata?: {
    createdAt: string;
    updatedAt: string;
    appVersion: string;
  };
}

// ========== 迁移系统 ==========

interface Migration {
  fromVersion: string;
  toVersion: string;
  description: string;
  migrate(data: VersionedEntityJSON): VersionedEntityJSON;
  validate?(data: VersionedEntityJSON): boolean;
}

class MigrationManager {
  private migrations: Migration[] = [];

  register(migration: Migration): void {
    this.migrations.push(migration);
  }

  migrate(
    data: VersionedEntityJSON,
    fromVersion: string,
    toVersion: string
  ): VersionedEntityJSON {
    const migrationPath = this.findMigrationPath(fromVersion, toVersion);

    let migratedData = data;
    for (const migration of migrationPath) {
      console.log(`执行迁移：${migration.description}`);
      migratedData = migration.migrate(migratedData);

      if (migration.validate && !migration.validate(migratedData)) {
        throw new Error(`迁移验证失败：${migration.description}`);
      }
    }

    return migratedData;
  }

  private findMigrationPath(from: string, to: string): Migration[] {
    const path: Migration[] = [];
    let current = from;

    while (current !== to) {
      const next = this.migrations.find(m => m.fromVersion === current);
      if (!next) {
        throw new Error(`找不到迁移路径：${current} → ${to}`);
      }
      path.push(next);
      current = next.toVersion;
    }

    return path;
  }
}

// ========== 注册迁移器 ==========

const migrationManager = new MigrationManager();

// v1.0.0 → v1.1.0：添加 visible 字段
migrationManager.register({
  fromVersion: '1.0.0',
  toVersion: '1.1.0',
  description: '为 StyleData 添加 visible 字段',
  migrate(data) {
    return {
      ...data,
      version: '1.1.0',
      entities: data.entities.map(entity => ({
        ...entity,
        dataList: entity.dataList.map(item => {
          if (item.type === 'StyleData') {
            return {
              ...item,
              data: { ...item.data, visible: true },
            };
          }
          return item;
        }),
      })),
    };
  },
});

// v1.1.0 → v2.0.0：重命名 color → fillColor
migrationManager.register({
  fromVersion: '1.1.0',
  toVersion: '2.0.0',
  description: '重命名 color → fillColor',
  migrate(data) {
    return {
      ...data,
      version: '2.0.0',
      entities: data.entities.map(entity => ({
        ...entity,
        dataList: entity.dataList.map(item => {
          if (item.type === 'StyleData') {
            const { color, ...rest } = item.data;
            return {
              ...item,
              data: { ...rest, fillColor: color },
            };
          }
          return item;
        }),
      })),
    };
  },
});

// ========== 存储与还原（带迁移） ==========

const CURRENT_VERSION = '2.0.0';

/**
 * 保存数据（带版本信息）
 */
function saveState(entityManager: EntityManager): void {
  const data: VersionedEntityJSON = {
    version: CURRENT_VERSION,
    entities: entityManager.storeState({ configOnly: false }),
    metadata: {
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      appVersion: CURRENT_VERSION,
    },
  };

  localStorage.setItem('flowgram-state', JSON.stringify(data));
  console.log(`✅ 已保存数据（版本 ${CURRENT_VERSION}）`);
}

/**
 * 还原数据（自动迁移）
 */
function restoreState(entityManager: EntityManager): void {
  const savedJSON = localStorage.getItem('flowgram-state');
  if (!savedJSON) {
    console.warn('未找到保存的数据');
    return;
  }

  try {
    const data: VersionedEntityJSON = JSON.parse(savedJSON);
    console.log(`读取数据版本：${data.version}`);

    // 如果版本不匹配，执行迁移
    let finalData = data;
    if (data.version !== CURRENT_VERSION) {
      console.log(`需要迁移：${data.version} → ${CURRENT_VERSION}`);

      // 备份原始数据
      const backupKey = `flowgram-backup-${data.version}-${Date.now()}`;
      localStorage.setItem(backupKey, savedJSON);

      // 执行迁移
      finalData = migrationManager.migrate(
        data,
        data.version,
        CURRENT_VERSION
      );

      // 保存迁移后的数据
      localStorage.setItem('flowgram-state', JSON.stringify(finalData));
      console.log('✅ 迁移完成并已保存');
    }

    // 还原实体
    entityManager.restoreState(finalData.entities);
    console.log(`✅ 已还原 ${finalData.entities.length} 个实体`);
  } catch (error) {
    console.error('❌ 还原失败:', error);
    throw error;
  }
}

// ========== 使用示例 ==========

function main() {
  const entityManager = new EntityManager();

  // 注册实体类型...
  // entityManager.registerEntity(RectangleEntity);

  // 还原数据（自动迁移）
  restoreState(entityManager);

  // ... 用户操作 ...

  // 保存数据
  saveState(entityManager);
}
```

---

## 总结

### 关键要点

1. **版本管理**：在数据中始终记录版本号
2. **迁移链**：支持跨版本迁移（v1.0 → v1.1 → v2.0）
3. **验证机制**：迁移后验证数据完整性
4. **降级方案**：迁移失败时的备份和恢复
5. **测试覆盖**：为每个迁移器编写单元测试

### 实施步骤

1. ✅ 在项目中引入 `MigrationManager`
2. ✅ 为每次不兼容变更编写迁移器
3. ✅ 在还原数据时自动执行迁移
4. ✅ 保留数据备份，防止迁移失败
5. ✅ 编写测试覆盖所有迁移路径

### 扩展阅读

- [存储还原完整示例](./3.存储还原完整示例.md)
- [ESC 系统架构](./2.ESC系统.md)
- [语义化版本控制规范](https://semver.org/)

