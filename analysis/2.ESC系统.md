# ECS

Flowgram.ai 采用 ECS (Entity-Component-System) 系统来管理应用数据。ESC 的核心理念在于将数据与逻辑彻底分离，从而实现高内聚、低耦合的系统设计。本文将从传统 OOP 模式入手，逐步介绍 ECS 架构的演进，并详细说明 Flowgram.ai 的实现方案。

## 一、传统面向对象编程 (OOP) 模式的问题

在常规的软件开发中，通常采用面向对象的方法，使用**继承**和**对象封装**来组织代码。

```ts
class GameObject {
  id: number;
  constructor(id: number) {
    this.id = id;
  }
}

class Player extends GameObject {
  position = { x: 0, y: 0 };
  velocity = { x: 1, y: 1 };

  update() {
    // 逻辑和数据死死绑定在一起
    this.position.x += this.velocity.x;
    this.position.y += this.velocity.y;
  }
}

const players: Player[] = [];

function gameLoop() {
  players.forEach((p) => p.update());

  requestAnimationFrame(gameLoop);
}

gameLoop();
```

这种模式在面对复杂系统时，会引入以下结构性问题：

1. **数据与逻辑耦合**：实体的行为逻辑与数据紧密绑定。难以灵活复用和扩展。
2. **类数量膨胀**：每当需要一个新的能力组合时，可能就需要创建一个新的类。
3. **多继承限制**：在不支持多继承（如 TypeScript）的语言中，实体难以组合多种不相关的能力。

## 二、简单 ECS (Naive ECS) 架构

ECS 架构旨在通过**组合优于继承**的原则来解决上述问题。它由三个基本部分构成：**Entity (实体)**、**Component (组件)**、**System (系统)**。

### 简单 ESC 实现示例

```ts
// 1. Component: 纯数据
class Position {
  constructor(public x: number, public y: number) {}
}
class Velocity {
  constructor(public x: number, public y: number) {}
}

// 2. Entity: 只是 ID
type EntityID = number;

// 3. World: 管理所有数据 (这里用简单的 Map 存储)
class World {
  nextId = 0;
  // 也就是：Map<ComponentType, Map<EntityID, ComponentData>>
  components = new Map<Function, Map<EntityID, any>>();

  createEntity(): EntityID {
    return ++this.nextId;
  }

  addComponent(entity: EntityID, component: any) {
    const type = component.constructor;
    if (!this.components.has(type)) {
      this.components.set(type, new Map());
    }
    this.components.get(type)!.set(entity, component);
  }

  // 获取某类组件的所有数据
  getComponents<T>(type: { new (...args: any[]): T }): Map<EntityID, T> {
    return (this.components.get(type) as Map<EntityID, T>) || new Map();
  }
}

// 4. System: 纯逻辑
class MovementSystem {
  update(world: World) {
    const positions = world.getComponents(Position);
    const velocities = world.getComponents(Velocity);

    // 遍历逻辑：找到同时拥有 Position 和 Velocity 的实体
    velocities.forEach((vel, entityId) => {
      if (positions.has(entityId)) {
        const pos = positions.get(entityId)!;
        pos.x += vel.x;
        pos.y += vel.y;
      }
    });
  }
}
```

### 简单 ECS 的局限性

1. **数据分散 (Scattered Data)**：不同组件数据在内存中不相邻，导致 CPU **缓存不命中 (Cache Miss)**。
2. **查找开销**：使用 `Map` 结构存储和查找，引入了哈希计算和指针跳转的开销。

---

## 三、Archetype ECS 架构

Archetype ECS 是一种优化内存布局和查询效率的 ECS 方案，常见于高性能游戏引擎。其核心思想是：将具有相同 Component 组合的实体数据**连续存储**。

### Archetype ESC 实现示例 (已优化排序逻辑提示)

```ts
// Component 定义保持不变
class Position {
  constructor(public x: number, public y: number) {}
}
class Velocity {
  constructor(public x: number, public y: number) {}
}

type EntityID = number;

// Archetype: 存储具有相同组件组合的实体数据
class Archetype {
  // 该 Archetype 包含的组件类型列表
  componentTypes: Set<Function>;
  // 实体 ID 数组（连续存储）
  entities: EntityID[] = [];
  // 按组件类型存储的数据数组（连续存储）
  components: Map<Function, any[]> = new Map();

  constructor(componentTypes: Function[]) {
    this.componentTypes = new Set(componentTypes);
    // 为每种组件类型创建数组
    componentTypes.forEach((type) => {
      this.components.set(type, []);
    });
  }

  // 添加实体
  addEntity(entityId: EntityID, componentData: Map<Function, any>) {
    const index = this.entities.length;
    this.entities.push(entityId);

    // 为每个组件添加数据
    componentData.forEach((data, type) => {
      if (this.components.has(type)) {
        this.components.get(type)!.push(data);
      }
    });

    return index;
  }

  // 移除实体（通过 swap-and-pop 优化）
  removeEntity(index: number) {
    const lastIndex = this.entities.length - 1;
    if (index < lastIndex) {
      // 将最后一个元素移到当前位置
      this.entities[index] = this.entities[lastIndex];
      this.components.forEach((arr) => {
        arr[index] = arr[lastIndex];
      });
    }
    // 删除最后一个元素
    this.entities.pop();
    this.components.forEach((arr) => arr.pop());
  }
}

// World 管理多个 Archetype
class ArchetypeWorld {
  nextId = 0;
  // 所有的 Archetype
  archetypes: Archetype[] = [];
  // 实体 ID 到 Archetype 的映射
  entityToArchetype: Map<EntityID, { archetype: Archetype; index: number }> =
    new Map();

  createEntity(): EntityID {
    return ++this.nextId;
  }

  // 添加组件到实体
  addComponents(entityId: EntityID, components: any[]) {
    const componentTypes = components.map((c) => c.constructor);

    // 查找或创建对应的 Archetype
    let archetype = this.findArchetype(componentTypes);
    if (!archetype) {
      archetype = new Archetype(componentTypes);
      this.archetypes.push(archetype);
    }

    // 构建组件数据 Map
    const componentData = new Map<Function, any>();
    components.forEach((c) => {
      componentData.set(c.constructor, c);
    });

    // 添加到 Archetype
    const index = archetype.addEntity(entityId, componentData);
    this.entityToArchetype.set(entityId, { archetype, index });
  }

  // 查找包含指定组件类型的 Archetype (简化实现，实际应用中会使用哈希键)
  private findArchetype(componentTypes: Function[]): Archetype | undefined {
    // 为了确保组合一致性，对组件类型进行排序比较
    const sortedComponentTypes = [...componentTypes].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    return this.archetypes.find((archetype) => {
      if (archetype.componentTypes.size !== sortedComponentTypes.length)
        return false;
      const archetypeSortedTypes = [...archetype.componentTypes].sort((a, b) =>
        a.name.localeCompare(b.name)
      );
      // 检查所有类型是否完全匹配
      return sortedComponentTypes.every(
        (type, i) => archetypeSortedTypes[i] === type
      );
    });
  }

  // 查询拥有指定组件的所有实体，示例只写了4个泛型
  query<T1>(type1: { new (...args: any[]): T1 }): Array<[EntityID, T1]>;
  query<T1, T2>(
    type1: { new (...args: any[]): T1 },
    type2: { new (...args: any[]): T2 }
  ): Array<[EntityID, T1, T2]>;
  query<T1, T2, T3>(
    type1: { new (...args: any[]): T1 },
    type2: { new (...args: any[]): T2 },
    type3: { new (...args: any[]): T3 }
  ): Array<[EntityID, T1, T2, T3]>;
  query<T1, T2, T3, T4>(
    type1: { new (...args: any[]): T1 },
    type2: { new (...args: any[]): T2 },
    type3: { new (...args: any[]): T3 },
    type4: { new (...args: any[]): T4 }
  ): Array<[EntityID, T1, T2, T3, T4]>;
  // 通用实现：支持任意数量的组件类型
  query(...types: Array<{ new (...args: any[]): any }>): Array<any[]> {
    const results: Array<any[]> = [];

    // 遍历所有 Archetype
    for (const archetype of this.archetypes) {
      // 只处理包含所有必需组件的 Archetype
      if (types.every((type) => archetype.componentTypes.has(type))) {
        // 获取所有需要的组件数组
        const componentArrays = types.map(
          (type) => archetype.components.get(type)!
        );

        // 数据是连续存储的，可以高效遍历
        for (let i = 0; i < archetype.entities.length; i++) {
          // 构建结果：[EntityID, ...components]
          const result = [
            archetype.entities[i],
            ...componentArrays.map((arr) => arr[i]),
          ];
          results.push(result);
        }
      }
    }

    return results;
  }
}

// System 使用 Archetype World
class MovementSystem {
  update(world: ArchetypeWorld) {
    // 一次性查询出所有同时拥有 Position 和 Velocity 的实体
    const entities = world.query(Position, Velocity);

    // 直接遍历，数据在内存中是连续的
    entities.forEach(([entityId, pos, vel]) => {
      pos.x += vel.x;
      pos.y += vel.y;
    });
  }
}

// 更多查询示例
class RenderSystem {
  update(world: ArchetypeWorld) {
    // 查询单个组件：所有拥有 Position 的实体
    const positions = world.query(Position);
    positions.forEach(([entityId, pos]) => {
      console.log(`实体 ${entityId} 位置: (${pos.x}, ${pos.y})`);
    });
  }
}

class PhysicsSystem {
  update(world: ArchetypeWorld) {
    // 查询三个组件：Position, Velocity, 和 Mass
    class Mass {
      constructor(public value: number) {}
    }

    const entities = world.query(Position, Velocity, Mass);
    entities.forEach(([entityId, pos, vel, mass]) => {
      // 物理计算：F = ma，这里简化为更新速度
      pos.x += vel.x;
      pos.y += vel.y;
      // 可以根据质量调整速度等
    });
  }
}
```

### Archetype 架构的特点

这种架构将相同的 Archetype 顺序存储，在遍历和查找的速度都非常快。

Archetype 和传统 OOP 中的类的概念非常相似，假设你在做一个 RPG 游戏，为了获得极致性能，你决定为每一种组合写一个 Class（或 Struct），放在数组里：

```ts
// 士兵：能跑，有血量
class Soldier {
  pos: Position;
  hp: Health;
}
const soldiers: Soldier[] = [];

// 箭塔：不能跑，有血量
class Tower {
  pos: Position;
  hp: Health;
}
const towers: Tower[] = [];

// 子弹：能跑，没血量
class Bullet {
  pos: Position;
}
const bullets: Bullet[] = [];
```

然后，策划说：“我们要加一个‘移动箭塔’，它不仅有血量，还能移动。”

你需要加一个 `class MovingTower` 和 `const movingTowers: MovingTower[]`。策划又说：“我们要有个‘无敌兵’，有位置，能跑，但没有血量（不需要 Health 字段以节省内存）。

你需要加一个 `class InvincibleSoldier` 和 `const invincibleSoldiers: ...`。

最后的结果就是，如果你有 10 种组件（位置、移动、血量、攻击、魔法、阵营...），它们的排列组合是 `2^10 = 1024` 种。你不可能手写 1000 个 Class，并维护 1000 个数组。

Archetype ECS 帮你自动做了这件事。

当你创建一个 Entity 并赋予 `{ Position, Health }` 时，ECS 引擎会在后台自动生成类似 `Soldier` 的内存布局。 当你创建另一个 Entity 并赋予 `{ Position }` 时，ECS 引擎会在后台自动生成类似 `Bullet` 的内存布局。

## 四、Flowgram.ai 的 ECS 系统设计

Flowgram.ai 采用的 ECS 架构是一种针对 Web 应用特点定制的方案, 它和 Archetype ECS 最大的区别在于它们为不同应用场景设计的性能模型和数据同步机制。

Archetype ECS 主要为极致批处理性能设计，适应游戏主循环模型，而 Flowgram.ai ECS 则为高效的开发体验和实时响应能力设计，适应事件驱动模型

### Flowgram ECS 的核心差异

| 方面          | 传统 Archetype ECS   | Flowgram ECS (Web 应用)                  |
| :------------ | :------------------- | :--------------------------------------- |
| **Component** | 纯数据结构 (POD)     | **EntityData** 类，包含响应式事件系统。  |
| **Entity**    | 纯 ID                | 包含管理逻辑和类型检查的容器对象。       |
| **内存布局**  | Archetype 连续数组   | 对象引用和 Map 索引。                    |
| **系统逻辑**  | 显式独立 System 循环 | 通过**事件订阅**或**查询函数**实现逻辑。 |

### 核心组件结构

```text
┌─────────────────┐
│ EntityManager   │  管理所有 Entity，提供查询和事件
└────────┬────────┘
         │ 1:N
         ▼
┌─────────────────┐
│    Entity       │  实体容器，管理 EntityData
└────────┬────────┘
         │ 1:N
         ▼
┌─────────────────┐
│  EntityData     │  纯数据组件 (带事件能力)
└─────────────────┘
```

### 核心设计点分析

#### 1\. Entity：带有管理能力的容器

`Entity` 是一个包含数据管理逻辑的对象，用于提供类型安全和简化的 API。

```ts
// 辅助类型定义 (为了让示例代码可运行，这里假设了 Emitter 的接口)
class Emitter<T> {
  private _listeners: ((data: T) => void)[] = [];
  event = (listener: (data: T) => void) => {
    this._listeners.push(listener);
    return () => {
      // 返回一个取消订阅函数
      this._listeners = this._listeners.filter((l) => l !== listener);
    };
  };
  fire(data: T) {
    this._listeners.forEach((listener) => listener(data));
  }
}
type EntityDataRegistry<D extends EntityData = EntityData> = {
  new (entity: Entity): D;
  type: string;
};
type EntityDataProps<D extends EntityData> = D extends EntityData<infer P>
  ? P
  : any;

class Entity {
  private _id: string; // 唯一标识
  private _version: number = 0; // 版本号，用于检测变化
  protected dataManager: Map<string, EntityData> = new Map(); // 持有的数据
  public changeLocked: boolean = false; // 用于批量更新锁

  protected onEntityChangeEmitter = new Emitter<Entity>();
  readonly onEntityChange = this.onEntityChangeEmitter.event;

  constructor(opts: { id: string }) {
    // ....简化构造函数
    this._id = opts.id;
  }

  // 添加数据
  addData<D extends EntityData>(
    Registry: EntityDataRegistry,
    defaultProps?: EntityDataProps<D>
  ): D {
    const entityData = new Registry(this);
    if (defaultProps) {
      entityData.update(defaultProps); // 初始化默认数据
    }
    this.dataManager.set(Registry.type, entityData);

    // 监听数据变化，触发 Entity 变化
    entityData.onDataChange(() => {
      this.fireChange();
    });

    return entityData;
  }

  // 查询数据
  getData<D extends EntityData>(
    Registry: EntityDataRegistry<D>
  ): D | undefined {
    return this.dataManager.get(Registry.type) as D;
  }

  // 检查是否有指定数据
  hasData(Registry: EntityDataRegistry): boolean {
    return this.dataManager.has(Registry.type);
  }

  // 触发实体变化事件
  protected fireChange(): void {
    if (this.changeLocked) return; // 如果被锁定，则不触发
    this._version++;
    this.onEntityChangeEmitter.fire(this);
  }

  get id(): string {
    return this._id;
  }
  get version(): number {
    return this._version;
  }
}
```

#### 2\. EntityData：响应式数据组件

`EntityData` 增加了事件发射器和版本号机制，支持数据变化后的自动通知。

```ts
abstract class EntityData<DATA = any> {
  static type = "EntityData"; // 类型标识

  protected _data: DATA; // 实际数据
  protected _version = 0; // 数据版本
  protected _entity: Entity; // 引用所属的 Entity 实例

  // 事件发射器
  protected onDataChangeEmitter = new Emitter<EntityData<DATA>>();
  readonly onDataChange = this.onDataChangeEmitter.event;

  constructor(entity: Entity) {
    this._entity = entity;
    this._data = this.getDefaultData(); // 初始化默认数据
  }

  // 抽象方法，强制子类实现提供默认数据
  abstract getDefaultData(): DATA;

  // 检查数据是否有实际变化（浅比较）
  protected checkChanged(props: Partial<DATA>): boolean {
    for (const key in props) {
      if (props.hasOwnProperty(key)) {
        if ((this._data as any)[key] !== (props as any)[key]) {
          return true;
        }
      }
    }
    return false;
  }

  // 更新数据
  update(props: Partial<DATA>): void {
    if (this.checkChanged(props)) {
      this._data = { ...this._data, ...props };
      this.fireChange(); // 触发变化事件
    }
  }

  // 触发变化
  protected fireChange(): void {
    this._version++;
    this.onDataChangeEmitter.fire(this);
  }

  // 获取数据副本 (防止外部直接修改)
  get data(): DATA {
    return { ...this._data };
  }

  // 序列化/反序列化 (保留了文章原始的toJSON/fromJSON结构)
  toJSON(): any {
    return this.data;
  }
  fromJSON(data: object): void {
    this.update(data);
  }
}
```

#### 3\. EntityManager：全局协调者

`EntityManager` 负责实体的创建、查询和生命周期管理，并按 Entity 类型进行索引。

```ts
type EntityRegistry<T extends Entity = Entity> = {
  new (...args: any[]): T;
  type: string;
  getDefaultDataRegistries?(): EntityDataRegistry[];
};

class EntityManager {
  protected nextEntityId: number = 0;
  // 按 ID 索引的实体
  protected entityInstanceMap: Map<string, Entity> = new Map();

  // 按类型索引的实体（类似 Archetype 的思想）
  protected entityInstanceMapByType: Map<string, Entity[]> = new Map();

  // 版本管理 (未在外部使用，可简化)
  // protected entityVersionMap: Map<string, number> = new Map();

  // 存储实体，并更新类型索引
  protected saveEntity(entity: Entity) {
    const type = (entity.constructor as EntityRegistry).type;
    this.entityInstanceMap.set(entity.id, entity);

    if (!this.entityInstanceMapByType.has(type)) {
      this.entityInstanceMapByType.set(type, []);
    }
    this.entityInstanceMapByType.get(type)!.push(entity);
  }

  // 创建实体
  createEntity<T extends Entity>(Registry: EntityRegistry, opts?: any): T {
    const id = `entity_${++this.nextEntityId}`;
    const entity = new Registry({ id, entityManager: this, ...opts }) as T;

    // 自动添加默认组件
    const defaultData = Registry.getDefaultDataRegistries
      ? Registry.getDefaultDataRegistries()
      : [];
    defaultData.forEach((DataReg) => {
      entity.addData(DataReg);
    });

    this.saveEntity(entity);
    return entity;
  }

  // 按类型查询实体
  getEntities<T extends Entity>(registry: EntityRegistry): T[] {
    return (this.entityInstanceMapByType.get(registry.type) as T[]) || [];
  }

  // 按 EntityData 类型查询 (实际System更常使用的方式)
  getEntityDatas<T extends EntityData>(
    entityRegistry: EntityRegistry,
    dataRegistry: EntityDataRegistry<T>
  ): T[] {
    // 遍历特定 Entity 类型，然后过滤掉没有 Data 的 Entity
    return this.getEntities(entityRegistry)
      .map((e) => e.getData(dataRegistry))
      .filter((d) => !!d) as T[];
  }
}
```

### 完整示例：Flowgram ESC 实战

```ts
// 1. 定义 EntityData（Component）
class PositionData extends EntityData<{ x: number; y: number }> {
  static type = "PositionData";

  getDefaultData() {
    return { x: 0, y: 0 };
  }
}

class VelocityData extends EntityData<{ vx: number; vy: number }> {
  static type = "VelocityData";

  getDefaultData() {
    return { vx: 0, vy: 0 };
  }
}

// 2. 定义 Entity 类型 (继承自基础 Entity，补充默认数据列表)
class MovableEntity extends Entity {
  static type = "MovableEntity";

  // 声明默认的 EntityData
  static getDefaultDataRegistries() {
    return [PositionData, VelocityData];
  }
}

// 3. 使用
const entityManager = new EntityManager();

// 创建实体
const entity = entityManager.createEntity(MovableEntity);

// 访问数据
const posData = entity.getData(PositionData)!;
const velData = entity.getData(VelocityData)!;

console.log(posData.data); // { x: 0, y: 0 }

// 更新数据
posData.update({ x: 10, y: 20 });
velData.update({ vx: 1, vy: 2 });

// 4. "System" 的实现（通过事件或手动查询）

// 方式 1: 事件驱动
posData.onDataChange(() => {
  console.log("位置变化:", posData.data);
});

// 方式 2: 主动查询 (MovementSystem)
function movementSystem(entityManager: EntityManager) {
  const entities = entityManager.getEntities(MovableEntity);

  entities.forEach((entity) => {
    const pos = entity.getData(PositionData);
    const vel = entity.getData(VelocityData);

    if (pos && vel) {
      pos.update({
        x: pos.data.x + vel.data.vx,
        y: pos.data.y + vel.data.vy,
      });
    }
  });
}

// 游戏循环
function gameLoop() {
  movementSystem(entityManager);
  // requestAnimationFrame(gameLoop); // 实际运行中启用
}
```

### Flowgram ESC 的优势与权衡

Flowgram ESC 是一个**务实的架构选择**，它平衡了性能、开发效率和可维护性。

#### 优势

1. **类型安全**：充分利用 TypeScript 确保编译时类型检查。
2. **响应式**：数据变化自动通知，利于 UI 框架集成。
3. **开发效率高**：API 直观，避免了复杂的 Archetype 概念。

#### 权衡

1. **性能不如纯 Archetype**：使用 Map 查找，缓存友好性较差，但在 Web 应用实体数量限制下通常足够。
2. **内存开销更大**：Entity 和 EntityData 都是对象实例，有额外的元数据开销。
3. **事件系统开销**：通过 `changeLocked` 和版本号机制进行批量处理和优化。
