# PlaygroundContribution 系统

`PlaygroundContribution` 是 FlowGram 画布引擎的核心扩展机制，采用**贡献点（Contribution）模式**实现功能扩展。

该机制允许开发者在不修改核心代码的情况下，通过实现接口来扩展画布功能，实现高度的模块化和可插拔性。

> 这里查个题外话，最早看到这种机制还是在 `VSCode` 上，`FlowGram.AI` 中感觉更类似 `Theia IDE` 中的风格。

## 一、核心组件

### 1.1 PlaygroundContribution 接口

`PlaygroundContribution` 接口定义了扩展画布功能所需实现的生命周期钩子：

```typescript
export interface PlaygroundContribution {
  /**
   * 注册 Layer/Entity/Able 相关
   * @param registry
   * @deprecated
   */
  registerPlayground?(registry: PlaygroundRegistry): void;
  /**
   * 初始化画布 (onReady 之前)
   * @param playground
   */
  onInit?(playground: Playground): void;
  /**
   * 初始化 entity 完毕后触发
   * @param playground
   */
  onReady?(playground: Playground): void;
  /**
   * 销毁
   * @param playground
   */
  onDispose?(playground: Playground): void;

  /**
   * 所有 Layer 第一次渲染完毕后触发
   * @param playground
   */
  onAllLayersRendered?(playground: Playground): void;
}
```

**生命周期执行顺序**：

1. `registerPlayground`（已废弃，不建议使用）
2. `onInit` - 画布初始化时调用，此时可以注册 Layer、Entity 等
3. `onReady` - Entity 初始化完毕后调用，此时可以访问已创建的 Entity
4. `onAllLayersRendered` - 所有 Layer 第一次渲染完成后调用
5. `onDispose` - 画布销毁时调用，用于清理资源

### 1.2 PlaygroundRegistry 类

`PlaygroundRegistry` 是一个注册表类，提供了统一的方式来注册画布的各种组件：

```typescript
@injectable()
export class PlaygroundRegistry {
  @inject(PipelineRegistry) protected readonly pipeline: PipelineRegistry;
  @inject(EntityManager) readonly entityManager: EntityManager;
  @inject(PlaygroundConfig) readonly playgroundConfig: PlaygroundConfig;

  // 配置画布
  config(config: Partial<PlaygroundConfig>): void {
    Object.assign(this.playgroundConfig, config);
  }

  // 注册图层
  registerLayer(layerRegistry: LayerRegistry): void {
    this.pipeline.registerLayer(layerRegistry);
  }

  // 注册实体
  registerEntity(entityRegistry: EntityRegistry): void {
    this.entityManager.registerEntity(entityRegistry);
  }

  // 注册编辑器状态
  registerEditorState(state: EditorState): void {
    const stateConfig = this.entityManager.getEntity<EditorStateConfigEntity>(
      EditorStateConfigEntity
    );
    stateConfig?.registerState(state);
  }
}
```

**主要功能**：

- `registerLayer()` - 注册新的图层（Layer）

  > 这个 `Layer` 并不是 `PhotoShop` 中的图层的概念，更偏向于 ECS 架构中的 System，它只关注一类实体并进行绘制，例如绘制节点和绘制线条可以分成两个 `Layer`。

- `registerEntity()` - 注册新的实体（Entity）
- `registerEditorState()` - 注册编辑器状态
- `config()` - 配置画布参数

## 二、在架构中的位置

### 2.1 与 Playground 的集成

`Playground` 类通过依赖注入系统（Inversify）获取所有的 `PlaygroundContribution` 实例，并在适当的生命周期阶段调用它们：

```typescript
@injectable()
export class Playground<CONTEXT = PlaygroundContext> implements Disposable {
  constructor(
    // ... 其他依赖
    @inject(ContributionProvider)
    @named(PlaygroundContribution)
    @optional()
    protected readonly contributionProvider: ContributionProvider<PlaygroundContribution> // ...
  ) {
    // 监听所有 Layer 渲染完成事件
    pipelineRenderer.onAllLayersRendered(() => {
      this.contributions.forEach((contrib) =>
        contrib.onAllLayersRendered?.(this)
      );
    });
  }

  protected get contributions(): PlaygroundContribution[] {
    return this.contributionProvider.getContributions();
  }

  init(): void {
    const { contributions } = this;
    // 先调用 registerPlayground（已废弃）
    for (const contrib of contributions) {
      if (contrib.registerPlayground) contrib.registerPlayground(this.registry);
    }
    // 然后调用 onInit
    for (const contrib of contributions) {
      if (contrib.onInit) contrib.onInit(this);
    }
  }

  ready(): void {
    // ... 其他初始化逻辑
    const { contributions } = this;
    // 调用 onReady
    for (const contrib of contributions) {
      if (contrib.onReady) contrib.onReady(this);
    }
  }

  dispose(): void {
    const { contributions } = this;
    // 调用 onDispose
    for (const contrib of contributions) {
      if (contrib.onDispose) contrib.onDispose(this);
    }
    this.toDispose.dispose();
  }
}
```

### 2.2 与插件系统的集成

FlowGram 的插件系统会将插件配置自动转换为 `PlaygroundContribution`，使得插件开发者可以通过更简洁的 API 来扩展功能：

```typescript
function toPlaygroundContainerModule<
  Options,
  CTX extends PluginContext = PluginContext
>(
  config: {
    onInit?: (ctx: CTX, opts: Options) => void;
    onDispose?: (ctx: CTX, opts: Options) => void;
    onReady?: (ctx: CTX, opts: Options) => void;
    onAllLayersRendered?: (ctx: CTX, opts: Options) => void;
  },
  opts: Options
): interfaces.ContainerModule {
  return new ContainerModule((bind) => {
    bind(PlaygroundContribution).toDynamicValue((ctx) => {
      const pluginContext = ctx.container.get<CTX>(PluginContext);
      return {
        onInit: () => {
          config.onInit?.(pluginContext, opts);
        },
        onReady: () => {
          config.onReady?.(pluginContext, opts);
        },
        onDispose: () => {
          config.onDispose?.(pluginContext, opts);
        },
        onAllLayersRendered: () => {
          config.onAllLayersRendered?.(pluginContext, opts);
        },
      };
    });
  });
}
```

这意味着当使用 `definePluginCreator` 创建插件时，传入的 `onInit`、`onReady` 等回调会自动被包装成 `PlaygroundContribution`。

### 2.3 依赖注入配置

在 `PlaygroundContainerModule` 中，`PlaygroundContribution` 被配置为贡献点提供者：

```typescript
export const PlaygroundContainerModule = new ContainerModule((bind) => {
  // ... 其他绑定
  bind(PlaygroundRegistry).toSelf().inSingletonScope();
  bind(Playground).toSelf().inSingletonScope();
  // 绑定贡献点提供者
  bindContributionProvider(bind, PlaygroundContribution);
  // ...
});
```

## 三、使用示例

### 3.1 直接实现 PlaygroundContribution

在测试或简单场景中，可以直接实现 `PlaygroundContribution` 接口：

```typescript
const container = createPlaygroundContainer();

container.bind(PlaygroundContribution).toConstantValue({
  onInit(playground: Playground) {
    // 注册自定义图层
    playground.registerLayer(Layer1);
    playground.registerLayer(Layer2);

    // 监听所有图层渲染完成
    playground.onAllLayersRendered(() => {
      console.log("所有图层已渲染完成");
    });
  },

  onReady(playground: Playground) {
    // Entity 已初始化，可以安全访问
    const layer1 = playground.getLayer(Layer1);
    console.log("Layer1 已就绪", layer1);
  },

  onAllLayersRendered(playground: Playground) {
    // 所有图层已渲染完成
    const layer1 = playground.getLayer(Layer1);
    const layer2 = playground.getLayer(Layer2);
    console.log("渲染次数", layer1.renderTimes, layer2.renderTimes);
  },

  onDispose(playground: Playground) {
    // 清理资源
    console.log("画布即将销毁");
  },
} as PlaygroundContribution);
```

### 3.2 通过插件系统使用

更推荐的方式是通过插件系统来扩展功能，这样代码更简洁且易于维护：

```typescript
export const createFreeLinesPlugin = definePluginCreator({
  singleton: true,

  onInit: (ctx: PluginContext, opts: FreeLinesPluginOptions) => {
    // 注册连线图层
    ctx.playground.registerLayer(WorkflowLinesLayer, {
      ...opts,
    });
  },

  onReady: (ctx: PluginContext, opts: FreeLinesPluginOptions) => {
    // Entity 已初始化，可以获取服务
    const linesManager = ctx.container.get(WorkflowLinesManager);

    // 注册不同类型的连线贡献点
    linesManager
      .registerContribution(WorkflowBezierLineContribution)
      .registerContribution(WorkflowFoldLineContribution)
      .registerContribution(WorkflowStraightLineContribution);

    // 注册用户自定义的连线贡献点
    if (opts.contributions) {
      opts.contributions.forEach((contribution) => {
        linesManager.registerContribution(contribution);
      });
    }

    // 设置默认连线类型
    if (opts.defaultLineType) {
      linesManager.switchLineType(opts.defaultLineType);
    }
  },
});
```

### 3.3 实现类形式的贡献点

也可以创建一个类来实现 `PlaygroundContribution` 接口：

```typescript
@injectable()
export class MyPlaygroundContribution implements PlaygroundContribution {
  @inject(SomeService) private readonly someService: SomeService;

  onInit(playground: Playground): void {
    // 初始化逻辑
    playground.registerLayer(MyCustomLayer);
  }

  onReady(playground: Playground): void {
    // 使用注入的服务
    this.someService.doSomething();
  }

  onDispose(playground: Playground): void {
    // 清理逻辑
  }
}

// 在容器中绑定
container.bind(PlaygroundContribution).to(MyPlaygroundContribution);
```

## 四、设计优势

### 4.1 高扩展性

通过实现 `PlaygroundContribution` 接口，开发者可以在不修改核心代码的情况下扩展画布功能。每个贡献点都是独立的，可以单独开发、测试和维护。

### 4.2 低耦合

贡献点与核心系统完全解耦，它们之间只通过接口进行交互。这使得系统更加灵活，易于重构和升级。

### 4.3 生命周期管理

提供了清晰的生命周期钩子，让开发者可以在合适的时机执行初始化、配置和清理操作：

- **onInit**: 适合注册组件、配置参数
- **onReady**: 适合访问已初始化的 Entity、建立服务间的依赖关系
- **onAllLayersRendered**: 适合在渲染完成后执行一些操作，如初始化动画、绑定事件等
- **onDispose**: 适合清理资源、取消订阅等

### 4.4 依赖注入支持

通过 Inversify 依赖注入容器，贡献点可以方便地获取所需的服务和依赖，实现真正的解耦。

### 4.5 插件化架构

与插件系统无缝集成，使得插件开发更加简单直观。插件开发者只需要关注业务逻辑，而不需要了解底层的贡献点机制。

## 五、相关文件

- **核心定义**: [playground-contribution.ts](../packages/canvas-engine/core/src/playground-contribution.ts)
- **Playground 类**: [playground.ts](../packages/canvas-engine/core/src/playground.ts)
- **容器配置**: [playground-container.ts](../packages/canvas-engine/core/src/playground-container.ts)
- **插件系统**: [plugin.ts](../packages/canvas-engine/core/src/plugin/plugin.ts)
- **测试示例**: [playground-contribution.spec.tsx](../packages/canvas-engine/core/__tests__/playground-contribution.spec.tsx)

## 六、总结

`PlaygroundContribution` 系统是 FlowGram 画布引擎扩展性的核心基础：

1. **定义了扩展接口** - `PlaygroundContribution` 接口提供了清晰的生命周期钩子
2. **提供了注册机制** - `PlaygroundRegistry` 类统一管理组件的注册
3. **支持插件化** - 与插件系统无缝集成，简化了扩展开发
4. **管理生命周期** - 在合适的时机调用扩展逻辑，确保执行顺序正确

该机制使得 FlowGram 能够以模块化、可插拔的方式组织功能，为构建复杂的工作流应用提供了坚实的基础。
