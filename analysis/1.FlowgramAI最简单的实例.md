# FlowgramAI 最简单的实例

## 初始化工程

使用 Rspack 初始化一个 React 前端工程:

```bash
pnpm create rsbuild@latest
```

## 安装依赖

```bash
pnpm add @flowgram.ai/free-layout-editor
```

```tsx
import {
  EditorRenderer,
  FreeLayoutEditorProvider,
  type WorkflowNodeProps,
  WorkflowNodeRenderer,
} from "@flowgram.ai/free-layout-editor";
import "@flowgram.ai/free-layout-editor/index.css";

const NodeRender = (props: WorkflowNodeProps) => {
  return (
    <WorkflowNodeRenderer
      style={{ width: 280, height: 88, background: "#fff", borderRadius: 8 }}
      node={props.node}
    >
      <div>
        {props.node.type} -- {props.node.id}
      </div>
    </WorkflowNodeRenderer>
  );
};

const App = () => {
  return (
    <FreeLayoutEditorProvider
      materials={{
        renderDefaultNode: NodeRender,
      }}
      nodeRegistries={[
        {
          type: "custom",
        },
      ]}
      initialData={{
        nodes: [
          {
            id: "1",
            type: "custom",
            meta: {
              position: { x: 250, y: 100 },
            },
          },
          {
            id: "2",
            type: "custom",
            meta: {
              position: { x: 400, y: 0 },
            },
          },
        ],
        edges: [],
      }}
    >
      <EditorRenderer />
    </FreeLayoutEditorProvider>
  );
};

export default App;
```

1. materials 是什么
2. nodeRegistries 是什么

这是一个很简单的结构，其中 [FreeLayoutEditorProvider](../packages/client/free-layout-editor/src/components/free-layout-editor-provider.tsx) 负责提供上下文，`EditorRenderer` 负责渲染编辑器。

- [PlaygroundReactProvider](../packages/canvas-engine/core/src/react/playground-react-provider.tsx)

但我们查看 `EditorRenderer` 的代码却发现这个组件几乎没有什么内容:

```tsx
export const PlaygroundReactRenderer: React.FC<PlaygroundReactRendererProps> = (
  props
) => {
  const playground = usePlayground();
  const playgroundConfig = useService<PlaygroundConfig>(PlaygroundConfig);
  const ref = useRef<any>();
  /**
   * 初始化画布
   */
  useEffect(() => {
    playground.setParent(ref.current);
    playground.ready();
    if (playgroundConfig.autoFocus) {
      playground.node.focus();
    }
  }, []);
  const PlaygroundComp = playground.toReactComponent();
  return (
    <>
      <div
        ref={ref}
        className={`gedit-playground-container${
          props.className ? ` ${props.className}` : ""
        }`}
        style={props.style}
      />
      <PlaygroundComp />
      {props.children
        ? ReactDOM.createPortal(<>{props.children}</>, playground.node)
        : null}
    </>
  );
};
```

最核心的渲染逻辑被放到了 `playground` 这个服务中了，这个组件只是简单的进行初始化和挂载 `PlaygroundComp`。

- [playground](../packages/canvas-engine/core/src/playground.ts)

接下来我们来拆解 `playground` 这个服务。

Playground 主要包含以下几个部分:

- [entityManager](../packages/canvas-engine/core/src/common/entity-manager.ts)
- [pipelineRenderer](../packages/canvas-engine/core/src/core/pipeline/pipeline-renderer.ts)
- [pipelineRegistry](../packages/canvas-engine/core/src/core/pipeline/pipeline-registry.ts)
- [pipeline](../packages/canvas-engine/core/src/core/pipeline/pipeline.ts)
- [layer](../packages/canvas-engine/core/src/core/layer/layer.ts)
- [contribution](../packages/canvas-engine/core/src/core/contribution/contribution.ts)
- [command](../packages/canvas-engine/core/src/core/command/command.ts)
- [selection](../packages/canvas-engine/core/src/core/selection/selection.ts)
