# 存储还原完整示例

本文档展示如何使用 FlowGram ESC 系统的 `toJSON()` 和 `fromJSON()` 实现完整的数据存储与还原功能。

## 目录

1. [定义 EntityData（数据组件）](#1-定义-entitydata数据组件)
2. [定义 Entity（实体）](#2-定义-entity实体)
3. [创建实体并设置数据](#3-创建实体并设置数据)
4. [序列化存储](#4-序列化存储)
5. [从存储还原](#5-从存储还原)
6. [完整示例代码](#6-完整示例代码)

---

## 1. 定义 EntityData（数据组件）

首先，我们需要定义实体所需的数据组件。每个 `EntityData` 代表实体的一个数据维度。

```typescript
import { EntityData } from "@flowgram.ai/canvas-engine/core";

// 位置数据组件
class PositionData extends EntityData<{ x: number; y: number }> {
  static type = "PositionData";

  getDefaultData() {
    return { x: 0, y: 0 };
  }
}

// 尺寸数据组件
class SizeData extends EntityData<{ width: number; height: number }> {
  static type = "SizeData";

  getDefaultData() {
    return { width: 100, height: 100 };
  }
}

// 样式数据组件
class StyleData extends EntityData<{
  color: string;
  opacity: number;
  visible: boolean;
}> {
  static type = "StyleData";

  getDefaultData() {
    return {
      color: "#000000",
      opacity: 1,
      visible: true,
    };
  }
}
```

**关键点：**

- 每个 `EntityData` 必须定义静态 `type` 属性（用于注册表查找）
- 必须实现 `getDefaultData()` 方法（提供默认值）
- 泛型参数定义数据结构类型

---

## 2. 定义 Entity（实体）

定义实体类，并声明它默认包含哪些数据组件。

```typescript
import {
  Entity,
  type EntityDataRegistry,
} from "@flowgram.ai/canvas-engine/core";

class RectangleEntity extends Entity {
  static type = "RectangleEntity";

  // 声明默认的数据组件
  getDefaultDataRegistries(): EntityDataRegistry[] {
    return [PositionData, SizeData, StyleData];
  }
}
```

**关键点：**

- 必须定义静态 `type` 属性
- `getDefaultDataRegistries()` 返回该实体类型默认包含的数据组件列表
- 这些组件会在实体创建时自动初始化

---

## 3. 创建实体并设置数据

使用 `EntityManager` 创建实体，并可以修改其数据。

```typescript
import { EntityManager } from "@flowgram.ai/canvas-engine/core";

// 创建 EntityManager（通常通过依赖注入获取）
const entityManager = new EntityManager();

// 创建矩形实体
const rectangle = entityManager.createEntity(RectangleEntity, {
  id: "rect-001", // 可选，不提供则自动生成
});

// 修改位置数据
rectangle.updateData(PositionData, { x: 100, y: 200 });

// 修改尺寸数据
rectangle.updateData(SizeData, { width: 300, height: 150 });

// 修改样式数据
rectangle.updateData(StyleData, {
  color: "#FF5733",
  opacity: 0.8,
  visible: true,
});

// 也可以通过 getData 获取数据实体后直接修改
const positionData = rectangle.getData(PositionData);
positionData.update({ x: 150, y: 250 });

console.log("当前实体数据：");
console.log("位置:", rectangle.getData(PositionData)?.data);
console.log("尺寸:", rectangle.getData(SizeData)?.data);
console.log("样式:", rectangle.getData(StyleData)?.data);
```

---

## 4. 序列化存储

将实体数据序列化为 JSON，并存储到 localStorage 或其他持久化存储。

### 4.1 单个实体序列化

```typescript
// 将单个实体序列化为 JSON
const entityJSON = rectangle.toJSON();

console.log("序列化后的 JSON：", JSON.stringify(entityJSON, null, 2));
// 输出：
// {
//   "type": "RectangleEntity",
//   "id": "rect-001",
//   "dataList": [
//     {
//       "type": "PositionData",
//       "data": { "x": 150, "y": 250 }
//     },
//     {
//       "type": "SizeData",
//       "data": { "width": 300, "height": 150 }
//     },
//     {
//       "type": "StyleData",
//       "data": { "color": "#FF5733", "opacity": 0.8, "visible": true }
//     }
//   ]
// }
```

### 4.2 批量实体序列化（推荐）

使用 `EntityManager.storeState()` 可以批量序列化所有实体：

```typescript
// 存储所有配置实体（ConfigEntity）
const allEntitiesJSON = entityManager.storeState({ configOnly: true });

// 或者存储所有实体（包括动态创建的）
const allEntitiesJSON = entityManager.storeState({ configOnly: false });

// 存储到 localStorage
localStorage.setItem("flowgram-state", JSON.stringify(allEntitiesJSON));
```

### 4.3 自定义存储逻辑

```typescript
// 存储函数
function saveToStorage(entityManager: EntityManager) {
  // 获取所有实体的 JSON 数据
  const entitiesJSON = entityManager.storeState({ configOnly: false });

  // 存储到 localStorage
  const storageKey = "flowgram-entities";
  localStorage.setItem(storageKey, JSON.stringify(entitiesJSON));

  console.log(`已存储 ${entitiesJSON.length} 个实体到 localStorage`);
  return entitiesJSON;
}

// 调用存储
const savedData = saveToStorage(entityManager);
```

---

## 5. 从存储还原

从持久化存储中读取 JSON 数据，并还原为运行时实体对象。

### 5.1 单个实体还原

```typescript
// 假设我们有一个序列化后的 JSON 数据
const savedJSON = {
  type: "RectangleEntity",
  id: "rect-001",
  dataList: [
    {
      type: "PositionData",
      data: { x: 150, y: 250 },
    },
    {
      type: "SizeData",
      data: { width: 300, height: 150 },
    },
    {
      type: "StyleData",
      data: { color: "#FF5733", opacity: 0.8, visible: true },
    },
  ],
};

// 创建新实体（使用相同的 ID）
const restoredEntity = entityManager.createEntity(RectangleEntity, {
  id: savedJSON.id,
});

// 从 JSON 还原数据
restoredEntity.fromJSON(savedJSON);

// 验证还原结果
console.log("还原后的位置:", restoredEntity.getData(PositionData)?.data);
console.log("还原后的尺寸:", restoredEntity.getData(SizeData)?.data);
console.log("还原后的样式:", restoredEntity.getData(StyleData)?.data);
```

### 5.2 批量实体还原（推荐）

使用 `EntityManager.restoreState()` 可以批量还原所有实体：

```typescript
// 从 localStorage 读取
function restoreFromStorage(entityManager: EntityManager) {
  const storageKey = "flowgram-entities";
  const savedJSON = localStorage.getItem(storageKey);

  if (!savedJSON) {
    console.warn("未找到存储的数据");
    return;
  }

  try {
    const entitiesJSON = JSON.parse(savedJSON);

    // 批量还原所有实体
    entityManager.restoreState(entitiesJSON);

    console.log(`已还原 ${entitiesJSON.length} 个实体`);
  } catch (error) {
    console.error("还原数据失败:", error);
  }
}

// 调用还原
restoreFromStorage(entityManager);
```

### 5.3 还原流程详解

`restoreState()` 内部执行以下步骤：

```typescript
// EntityManager.restoreState() 的简化流程
restoreState(data: EntityJSON[]): void {
  data.forEach((s: EntityJSON) => {
    // 1. 验证数据有效性
    if (!s || !s.type || !s.id) return;

    // 2. 通过类型查找注册的 Entity 类
    const register = this.getRegistryByType(s.type);
    if (!register) {
      console.warn(`Entity registry lost: ${s.type}`);
      return;
    }

    // 3. 创建实体实例（使用保存的 ID）
    const entity = this.createEntity(register, {
      id: s.id,
    });

    // 4. 调用实体的 fromJSON 方法还原数据
    if (entity.fromJSON) {
      entity.fromJSON(s);
    }
  });
}
```

`fromJSON()` 内部执行：

```typescript
// Entity.fromJSON() 的简化流程
fromJSON(data?: EntityJSON | any): void {
  // 1. 验证数据
  if (!data || !data.id || !data.type) return;

  // 2. 锁定变更（避免中间状态触发事件）
  this.changeLocked = true;

  // 3. 重置实体到初始状态
  this.reset();

  // 4. 遍历 dataList，还原每个数据组件
  if (data.dataList) {
    data.dataList.forEach((d: any) => {
      // 4.1 通过类型查找数据组件注册表
      const registry = this.entityManager.getDataRegistryByType(d.type);

      if (registry) {
        // 4.2 创建数据组件实例
        const dataEntity = this.addData(registry);

        // 4.3 更新数据
        dataEntity.update(d.data);
      }
    });
  }

  // 5. 解锁并触发变更事件
  this.changeLocked = false;
  this.fireChange();
}
```

---

## 6. 完整示例代码

以下是一个完整的、可运行的示例：

```typescript
import {
  Entity,
  EntityData,
  EntityManager,
  type EntityDataRegistry,
  type EntityJSON,
} from "@flowgram.ai/canvas-engine/core";

// ========== 1. 定义数据组件 ==========

class PositionData extends EntityData<{ x: number; y: number }> {
  static type = "PositionData";

  getDefaultData() {
    return { x: 0, y: 0 };
  }
}

class SizeData extends EntityData<{ width: number; height: number }> {
  static type = "SizeData";

  getDefaultData() {
    return { width: 100, height: 100 };
  }
}

class StyleData extends EntityData<{
  color: string;
  opacity: number;
  visible: boolean;
}> {
  static type = "StyleData";

  getDefaultData() {
    return {
      color: "#000000",
      opacity: 1,
      visible: true,
    };
  }
}

// ========== 2. 定义实体 ==========

class RectangleEntity extends Entity {
  static type = "RectangleEntity";

  getDefaultDataRegistries(): EntityDataRegistry[] {
    return [PositionData, SizeData, StyleData];
  }
}

// ========== 3. 创建实体并设置数据 ==========

function createAndConfigureEntities(entityManager: EntityManager) {
  // 创建第一个矩形
  const rect1 = entityManager.createEntity(RectangleEntity, {
    id: "rect-001",
  });
  rect1.updateData(PositionData, { x: 100, y: 200 });
  rect1.updateData(SizeData, { width: 300, height: 150 });
  rect1.updateData(StyleData, {
    color: "#FF5733",
    opacity: 0.8,
    visible: true,
  });

  // 创建第二个矩形
  const rect2 = entityManager.createEntity(RectangleEntity, {
    id: "rect-002",
  });
  rect2.updateData(PositionData, { x: 500, y: 300 });
  rect2.updateData(SizeData, { width: 200, height: 200 });
  rect2.updateData(StyleData, {
    color: "#33C3F0",
    opacity: 0.9,
    visible: true,
  });

  console.log("✅ 创建了 2 个矩形实体");
  return { rect1, rect2 };
}

// ========== 4. 存储数据 ==========

function saveEntities(entityManager: EntityManager): EntityJSON[] {
  // 获取所有实体的 JSON 数据
  const entitiesJSON = entityManager.storeState({ configOnly: false });

  // 存储到 localStorage
  const storageKey = "flowgram-entities-demo";
  localStorage.setItem(storageKey, JSON.stringify(entitiesJSON));

  console.log(`✅ 已存储 ${entitiesJSON.length} 个实体到 localStorage`);
  console.log("存储的数据：", JSON.stringify(entitiesJSON, null, 2));

  return entitiesJSON;
}

// ========== 5. 还原数据 ==========

function restoreEntities(entityManager: EntityManager): void {
  const storageKey = "flowgram-entities-demo";
  const savedJSON = localStorage.getItem(storageKey);

  if (!savedJSON) {
    console.warn("⚠️ 未找到存储的数据");
    return;
  }

  try {
    const entitiesJSON: EntityJSON[] = JSON.parse(savedJSON);

    // 批量还原所有实体
    entityManager.restoreState(entitiesJSON);

    console.log(`✅ 已还原 ${entitiesJSON.length} 个实体`);

    // 验证还原结果
    const restoredRects = entityManager.getEntities(RectangleEntity);
    restoredRects.forEach((rect) => {
      console.log(`\n实体 ${rect.id}:`);
      console.log("  位置:", rect.getData(PositionData)?.data);
      console.log("  尺寸:", rect.getData(SizeData)?.data);
      console.log("  样式:", rect.getData(StyleData)?.data);
    });
  } catch (error) {
    console.error("❌ 还原数据失败:", error);
  }
}

// ========== 6. 主函数：完整流程演示 ==========

function main() {
  console.log("=== FlowGram 存储还原完整示例 ===\n");

  // 创建 EntityManager
  const entityManager = new EntityManager();

  // 注册 Entity 类型（通常在应用启动时完成）
  entityManager.registerEntity(RectangleEntity);

  console.log("--- 步骤 1: 创建并配置实体 ---");
  const { rect1, rect2 } = createAndConfigureEntities(entityManager);

  console.log("\n--- 步骤 2: 序列化并存储 ---");
  const savedData = saveEntities(entityManager);

  console.log("\n--- 步骤 3: 清空当前实体（模拟页面刷新）---");
  // 在实际场景中，这相当于页面刷新或重新初始化
  entityManager.removeEntity(rect1);
  entityManager.removeEntity(rect2);
  console.log(
    "当前实体数量:",
    entityManager.getEntities(RectangleEntity).length
  );

  console.log("\n--- 步骤 4: 从存储还原 ---");
  restoreEntities(entityManager);

  console.log("\n=== 示例完成 ===");
}

// 运行示例
// main();
```

---

## 关键要点总结

### 1. 注册表机制

- **Entity 注册**：使用 `entityManager.registerEntity(EntityClass)` 注册实体类型
- **EntityData 注册**：在 `addData()` 时自动注册，或手动调用 `entityManager.registerEntityData(DataClass)`

### 2. 序列化格式

```typescript
interface EntityJSON {
  type: string; // 实体类型
  id: string; // 实体 ID
  dataList: Array<{
    // 数据组件列表
    type: string; // 数据组件类型
    data: any; // 数据内容
  }>;
}
```

### 3. 还原流程

1. **验证数据**：检查 `id` 和 `type` 是否存在
2. **锁定变更**：避免还原过程中触发不必要的变更事件
3. **重置实体**：清空现有数据，回到初始状态
4. **类型查找**：通过注册表查找对应的类构造函数
5. **创建实例**：动态创建数据组件实例
6. **更新数据**：将 JSON 数据填充到实例中
7. **解锁通知**：触发变更事件，通知监听者

### 4. 最佳实践

- ✅ 使用 `EntityManager.storeState()` 和 `restoreState()` 进行批量操作
- ✅ 在应用启动时注册所有 Entity 和 EntityData 类型
- ✅ 使用固定的 ID 确保还原时实体 ID 一致
- ✅ 在存储前验证数据完整性
- ✅ 处理还原失败的情况（类型未注册、数据格式错误等）

---

## 实际应用场景

1. **页面刷新恢复**：用户刷新页面后，从 localStorage 还原画布状态
2. **撤销/重做**：将历史状态序列化，支持状态回退
3. **导入/导出**：将画布数据导出为 JSON 文件，或从文件导入
4. **云端同步**：将序列化数据上传到服务器，实现多端同步
5. **模板保存**：将常用配置保存为模板，快速复用

---

## 注意事项

⚠️ **类型注册顺序**：确保在还原前，所有用到的 Entity 和 EntityData 类型都已注册

⚠️ **ID 冲突**：还原时如果实体 ID 已存在，会创建失败（EntityManager 会检查）

⚠️ **数据版本兼容**：如果数据结构发生变化，需要实现数据迁移逻辑（详见 [数据迁移指南](./4.数据迁移指南.md)）

⚠️ **循环引用**：确保序列化的数据中没有循环引用（JSON.stringify 会失败）

---

## 扩展阅读

- [ESC 系统架构](./2.ESC系统.md)
- [数据迁移指南](./4.数据迁移指南.md) - 详细介绍如何处理数据版本兼容和迁移
- [Entity API 文档](../../packages/canvas-engine/core/src/common/entity.ts)
- [EntityManager API 文档](../../packages/canvas-engine/core/src/common/entity-manager.ts)
